<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Akka Cluster Singleton]]></title>
    <url>%2F2017%2F08%2F04%2Fakka-cluster-singleton%2F</url>
    <content type="text"><![CDATA[Akka集群单例​ 对于某些使用情况，方便、有时也是强制性的，以确保只有一个运行在群集某处的某个类型的actor。 例如： 针对集群范围内某些统一决策的单一责任点，或协调集群系统中的行为。 进入到外部系统的单点。 单个管理者，多个工作者。 统一命名服务或路由逻辑 ​ 使用单例不应该是程序设计的首选。它有几个缺点，例如单点瓶颈。单点故障也是一个相关的问题，但是在某些情况下，这个功能会通过确保最终启动另一个单例实例来处理这一点。 ​ 集群单例模式由akka.cluster.singleton.ClusterSingletonManager实现。它在所有集群节点或标有特定角色的一组节点之间管理一个单例Actor实例。 ClusterSingletonManager是一个Actor，应该在集群中的所有节点或具有指定角色的所有节点上启动。实际的单例Actor由最早的节点上的ClusterSingletonManager启动，通过从提供的Props创建一个子Actor。正在任何时间点，ClusterSingletonManager确保至多只有一个单例实例运行。 ​ 单例Actor总是在具有指定角色的最老的集群成员身上运行。最老的成员由akka.cluster.Member#isOlderThan决定。从群集中删除该成员时，可能会发生更改。请注意，在移交过程中有很短的一段时间里，单例是不活跃的。 ​ 集群故障检测器会注意到由于JVM崩溃，硬停机或网络故障等原因，最旧的节点变得无法访问。然后一个新的最旧的节点将接管，并创建一个新的单例Actor。对于这些失败的情况，将不会有优雅的交接，但是应通过一切合理的手段避免集群中存在一个以上的单例Actor。 ​ 可以使用akka.cluster.singleton.ClusterSingletonProxy访问单例Actor，它会将所有消息路由到单例的当前实例。ClusterSingletonProxy将跟踪集群中最旧的节点，并通过actorSelection向单例发送akka.actor.Identify消息并等待它回复来解析单例的ActorRef。如果单例在某个时间（可配置）内没有回复，则会定期执行。鉴于实现，可能存在ActorRef不可用的时间段，例如当节点离开集群时。 在这些情况下，ClusterSingletonProxy将缓冲发送给单例的消息，然后在单例最终可用时传递消息。如果缓冲区已满，当通过ClusterSingletonProxy发送新消息时，ClusterSingletonProxy将丢弃旧消息。缓冲区的大小是可配置的，并且可以通过使用缓冲区大小为0禁用它。 ​ 值得注意的是，由于这些Actor的分布性，消息总是会丢失的。一如以往，在单例（确认）和客户端Actor（重试）中应该实现额外的逻辑，以确保消息至少一次交付。 ​ 单例实例不会运行在状态为WeaklyUp的成员上。 需要注意的潜在问题​ 这种模式起初似乎是非常诱人的，但它有几个缺点，其中一些如下： 集群单例可能很快成为性能瓶颈。 不能指望集群单例是永远可用的。例如，当单例已经在运行的节点处于死亡状态时，注意需要几秒钟，并将单例迁移到另一个节点。 出现在使用Automatic Downing的群集中的网络分区的情况下（参见 Downing文档），可能会发生孤立的群集各自决定创建自己的单例，这意味着系统中可能会运行多个单例 ，但是集群无法找出它们（因为分区）。 ​特别是最后一点是应该注意的地方。一般来说，当使用Cluster Singleton模式时，应该自己负责downing节点，而不是依赖基于时序的自动关闭功能。 警告： ​ 不要将Cluster Singleton与自动Automatic Downing一起使用，因为它允许集群分成两个独立的集群，这反过来将导致多个Singleton启动，每个独立的集群中会有一个！ 示例​ 假设我们需要一个单独的入口到外部系统。从JMS队列接收消息的Actor，严格要求必须只有一个JMS消费者存在，才能确保消息按顺序处理。这可能不是想要设计的东西，但是与外部系统集成时的典型的现实场景。 ​ 在集群中的每个节点上，需要启动ClusterSingletonManager并提供单例Actor的Props，做为JMS队列消费者。 12345final ClusterSingletonManagerSettings settings = ClusterSingletonManagerSettings.create(system).withRole("worker");system.actorOf(ClusterSingletonManager.props( Props.create(Consumer.class, queue, testActor), new End(), settings), "consumer"); ​ 这里我们将单例限制为用“worker”角色标记的节点，但是所有节点，独立于角色，都可以通过不指定withRole来使用。 ​ 在这里，我们使用一个特定于应用程序的终端消息，在实际停止单例Actor之前关闭资源。请注意，如果只需要停止Actor，PoisonPill就是一个完美的终端消息。 ​ 使用上面给出的名称，可以使用正确配置的ClusterSingletonProxy从任何集群节点获取单例的访问。 1234ClusterSingletonProxySettings proxySettings = ClusterSingletonProxySettings.create(system).withRole("worker");system.actorOf(ClusterSingletonProxy.props("/user/consumer", proxySettings), "consumerProxy"); Distributed workers with Akka and Java!中提供了更全面的示例。 Dependencies​ 要使用Cluster Singleton，必须在项目中添加以下依赖项。 12345&lt;dependency&gt; &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt; &lt;artifactId&gt;akka-cluster-tools_2.11&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt;&lt;/dependency&gt; Configuration​ 当使用ActorSystem参数创建时，ClusterSingletonManagerSettings将读取以下配置属性。也可以修改ClusterSingletonManagerSettings，或者从另一个配置部分创建如下相同的布局。ClusterSingletonManagerSettings是ClusterSingletonManager.props工厂方法的参数，即每个单例可以根据需要配置不同的设置。 12345678910111213141516171819akka.cluster.singleton &#123; # The actor name of the child singleton actor. singleton-name = &quot;singleton&quot; # Singleton among the nodes tagged with specified role. # If the role is not specified it&apos;s a singleton among all nodes in the cluster. role = &quot;&quot; # When a node is becoming oldest it sends hand-over request to previous oldest, # that might be leaving the cluster. This is retried with this interval until # the previous oldest confirms that the hand over has started or the previous # oldest member is removed from the cluster (+ akka.cluster.down-removal-margin). hand-over-retry-interval = 1s # The number of retries are derived from hand-over-retry-interval and # akka.cluster.down-removal-margin (or ClusterSingletonManagerSettings.removalMargin), # but it will never be less than this property. min-number-of-hand-over-retries = 10&#125; ​ 当使用ActorSystem参数创建时，ClusterSingletonProxySettings将读取以下配置属性。也可以修改ClusterSingletonProxySettings，或者从另一个配置部分创建如下相同的布局。ClusterSingletonProxySettings是ClusterSingletonProxy.props工厂方法的参数，即每个单例代理可以根据需要配置不同的设置。 1234567891011121314151617181920akka.cluster.singleton-proxy &#123; # The actor name of the singleton actor that is started by the ClusterSingletonManager singleton-name = $&#123;akka.cluster.singleton.singleton-name&#125; # The role of the cluster nodes where the singleton can be deployed. # If the role is not specified then any node will do. role = &quot;&quot; # Interval at which the proxy will try to resolve the singleton instance. singleton-identification-interval = 1s # If the location of the singleton is unknown the proxy will buffer this # number of messages and deliver them when the singleton is identified. # When the buffer is full old messages will be dropped when new messages are # sent via the proxy. # Use 0 to disable buffering, i.e. messages will be dropped immediately if # the location of the singleton is unknown. # Maximum allowed buffer size is 10000. buffer-size = 1000 &#125; 本作品采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。]]></content>
      <categories>
        <category>Akka</category>
      </categories>
      <tags>
        <tag>Akka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[What is a “side effect?”]]></title>
    <url>%2F2017%2F08%2F02%2Fside-effect%2F</url>
    <content type="text"><![CDATA[函数的副作用​ 人们都说，一个纯粹的函数式程序是没有副作用的。那么什么是副作用呢？ ​ Wikipedia中是这样描述的：“在计算机科学中，函数副作用指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。” ​ 例如修改全局变量（函数外的变量）或修改参数。函数副作用会给程序设计带来不必要的麻烦，给程序带来十分难以查找的错误，并降低程序的可读性。严格的函数式语言要求函数必须无副作用。 ​ 副作用包括以下内容： IO输出 IO读 修改一个参数的状态，修改一个数据结构中的数据，或者修改一个对象的某个属性的值 抛出异常，或者当错误发生时停止整个程序 调用了其他有副作用的函数 ​下面是函数的副作用相关的几个概念，纯函数（Pure Function）、非纯函数（Impure Function）、引用透明（Referential Transparent）。 纯函数（Pure Function）​ ——输入输出数据流全是显式（Explicit）的。 ​ 显式（Explicit）的意思是，函数与外界交换数据只有一个唯一渠道——参数和返回值；函数从函数外部接受的所有输入信息都通过参数传递到该函数内部；函数输出到函数外部的所有信息都通过返回值传递到该函数外部。 非纯函数​ 如果一个函数通过隐式（Implicit）方式，从外界获取数据，或者向外部输出数据，那么，该函数就不是纯函数，叫作非纯函数（Impure Function）。 ​ 隐式（Implicit）的意思是，函数通过参数和返回值以外的渠道，和外界进行数据交换。比如，读取全局变量，修改全局变量，都叫作以隐式的方式和外界进行数据交换；比如，利用 I/O API（输入输出系统函数库）读取配置文件，或者输出到文件，打印到屏幕，都叫做隐式的方式和外界进行数据交换。 ​ I/O API 可以看作是一种特殊的全局变量。文件、屏幕、数据库等输入输出结构可以看作是独立于运行环境之外的系统外全局变量，而不是应用程序自己定义的全局变量。 ​ 纯函数内部有隐式（Implicit）的数据流，这种情况叫做副作用（Side Effect）。上述的I/O，外部变量等，都可以归为副作用。因此，纯函数的定义也可以写为“没有副作用的函数”。 引用透明​ 引用透明（Referential Transparent）的概念与函数的副作用相关，且受其影响。如果程序中任意两处具有相同输入值的函数调用能够互相置换，而不影响程序的动作，那么该程序就具有引用透明性。它的优点是比非引用透明的语言的语义更容易理解，不那么晦涩。纯函数式语言没有变量，所以它们都具有引用透明性。 特殊的函数副作用​ 上述只讨论了一般的情况，还有一种特殊的情况，我们没有讨论。有些函数的参数是一种 In/Out 作用的参数，即函数可能改变参数里面的内容，把一些信息通过输入参数，夹带到外界。这种情况，严格来说，也是副作用。也是非纯函数。 比如下面的函数。 12345process(context) &#123; a = context.getInfo() result = calculate(a) context.setResult(result) &#125; ​ 纯函数的特征​ 理论上，无副作用的函数更容易被测试。假设有一个把值相加的函数，如 + 。给定数字1和2，结果必定是3。一个像这样的无副作用的函数有如下特征： 输入不可变 结果一致 没有任何其他操作 纯函数的优点 无状态。线程安全。不需要线程同步。 纯函数相互调用组装起来的函数，还是纯函数。 应用程序或者运行环境（Runtime）可以对纯函数的运算结果进行缓存，运算加快速度。因为这样的函数没有副作用，它很容易被测试。 本作品采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。]]></content>
      <categories>
        <category>Functional_Programming</category>
      </categories>
      <tags>
        <tag>Functional_Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Design Pattern Essentials]]></title>
    <url>%2F2017%2F07%2F21%2Fdesign-pattern-essentials%2F</url>
    <content type="text"><![CDATA[设计模式精要​ 模式：是在某情境（context）下，针对某问题的某种解决方案。 设计原则 封装变化。（找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起） 针对接口编程，而不是针对实现编程。（”针对接口编程”真正的意思是”针对超类型(supertype)编程”） 多用组合，少用继承。 为了交互对象之间的松耦合设计而努力。 类应该对修改关闭，对扩展开放。（开闭原则） 要依赖抽象，不要依赖具体类。（依赖倒置原则） 只和你的密友谈话。（最少知识原则） 避免底层组件直接调用高层组件。（”好莱坞原则” - “Don’t call me, I’ll call you.”） 一个类应该只有一个引起变化的原因。（单一职责） ​将你的思绪集中在设计本身，而不是在模式上。只有在真正需要时才使用模式。过度使用设计模式可能导致代码被过度工程化。应该总是用最简单的解决方案完成工作，并在真正需要模式的地方才使用它。 要点 良好的OO设计必须具备可复用、可扩充、可维护三个特征。 常把系统中会变化的部分抽出来封装。 松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。 继承属于扩展形式之一，但不见得是达到弹性设计的最佳方式。 在我们的设计中，应该允许行为被扩展，而无需修改现有的代码。 组合和委托可用于在运动时动态地加上新的行为。 依赖倒置原则： 变量不可以持有具体类的引用。 不要让类派生自具体类。 不要覆基类中已实现的方法。 内聚： 用来度量一个类或模块紧密地达到单一目的或责任。当一个模块或者一个类被设计成只支持一组相关的功能时，我们说它具有高内聚。反之，当被设计成支持一组不相关的功能时，我们说它具有低内聚。内聚是一个比单一职责原则更普遍的概念，但两者的关系其实是很密切的。遵守单一职责的类容易具有很高的聚合力，而且比背负许多责任的低内聚类更容易维护。 OO模式：策略模式：​ 定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。 观察者模式：​ 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖者都会收到通知并自动更新。 装饰者模式：​ 动态的将责任附加到对象上。若要拓展功能，装饰者提供了比继承更有弹性的替代方案。 工厂方法模式：​ 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 抽象工厂模式：​ 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 单例模式：​ 确保一个类只有一个实例，并提供一个全局访问点。 命令模式：​ 将“请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持可撤销操作。 适配器模式：​ 将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 外观模式：​ 提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 模板方法模式：​ 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 迭代器模式：​ 提供一种方法，顺序访问一个聚合器对象中的各个元素，而又不暴露其内部的表示。把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。 组合模式：​ 允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。在实现组合模式时，有许多设计上的折中。要根据需要平衡透明性和安全性。 状态模式：​ 允许对象在内部状态改变时改变它的行为，对象基于内部状态而拥有不同的行，对象看起来好像修改了它的类。 代理模式：​ 使用代理模式创建代表（representative）对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。 生成器模式：​ 封装一个产品的构造过程，允许按步骤构造并可以改变过程。 本作品采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。]]></content>
      <categories>
        <category>Design_Pattern</category>
      </categories>
      <tags>
        <tag>Design_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Introduction to Akka]]></title>
    <url>%2F2017%2F06%2F25%2Fakka-Introduction%2F</url>
    <content type="text"><![CDATA[Akka：Introduction to AkkaAkka及Actor Model介绍。 1. Akka简介​ Akka，一组用于设计跨越处理器核心和网络的可扩展、有弹性的系统的开源库。Akka允许您专注于满足业务需求，而不是编写底层代码来保证可靠的行为、容错和高性能。 ​ 通用的实践和编程模型并没有解决对于现代计算机结构而设计系统的固有挑战。分布式系统必须要应对因环境组件崩溃导致无法响应、消息丢失且没有在线路上留下痕迹，网络延迟波动等一系列问题。这些问题在精心管理的数据中心内环境中经常出现 - 在虚拟架构中更是如此。 ​ 为了应对这些现实，Akka提供： 多线程行为，不使用低级并发结构，如atomics 或 locks。甚至不需要考虑内存可见性问题。 系统及其组件之间的透明远程通信。不需要编写或维护困难的网络通讯代码。 一个有弹性的集群，高可用架构，按需扩展或缩小。 ​ 所有这些功能都可以通过统一的编程模型获得：Akka利用了Actor模型来提供一个抽象模型，使得更容易编写正确的并发、并行和分布式的系统。Actor模型贯穿整个Akka库，提供了一致的理解和使用方式。因此，Akka高度集成，您无法通过选择库来解决个别问题并尝试将它们拼凑在一起。 ​ 通过学习Akka及其Actor模型，您可以得到一整套广泛而深入的工具，解决困难的分布式/并行系统问题。 2. 什么是Actor模型 当今计算环境的特点与以往编程模式的构思有很大不同。Actor几十年前被 Carl Hewitt发明。但是最近，它们对现代计算机系统的挑战的适用性已得到承认并被证明是有效的。 ​ Actor模型提供了一种抽象，可以让您在交流层面考虑您的代码，与大型组织中的人相同。Actor的基本特征是，他们将世界建模成通过明确的消息传递来相互交流的有状态实体。 作为计算实体，Actor具有以下特征： 它们通过消息通信异步执行，而不是方法调用。 它们管理自己的状态。 响应消息时，他们可以： 创建其他（子）Actor 发送消息给其他Actor 停止（子）Actor或自己 3. Actor 模型解决什么问题？ Akka使用Actor模型来克服传统面向对象编程模型的局限性，并满足高分布式系统的独特挑战。为了充分了解Actor模型的必要性，它有助于识别传统的编程方法与并发、分布式计算的现实的不匹配。 1. 封装的错误认识​ 面向对象编程（OOP）是一个广泛接受的编程模型。其核心思想之一就是封装。封装规定对象的内部数据不能直接从外部访问; 它只能通过调用一组辅助方法来修改。该对象负责暴露安全操作，以保护其封装数据的不变性。 ​ 例如，对有序二叉树实现的操作不能改变树的次序。调用者期望排序是完整的，并且当查询树的某一数据时，他们需要能够依赖这个约束。 ​ 当我们分析OOP运行行为时，我们有时会绘制一个显示方法调用交互的消息序列图。例如： ​ 不幸的是，上述图表并不能准确地表示实例在执行过程中的生命线。实际上，线程执行所有这样的调用，并且变量的执行发生在调用该方法的同一线程上。通过执行线程更新上图，看起来像这样： ​ 当您尝试对多线程发生的情况进行建模时，我们整齐绘制的图形变得勉强。我们可以尝试说明访问同一个实例的多个线程： ​ ​ 有一个执行部分，两个线程调用相同的方法。不幸的是，对象的封装模型并不能保证该部分发生什么。若在两个线程之间不进行任何的协调，两个调用的指令可以以任意方式进行交织，则无法保证封装数据的不变性。现在，这个问题由于许多线程的存在而加剧。 . 解决这个问题的常见方式是在这些方法上添加一个锁。虽然这样确保了在任何给定时间最多只有一个线程将调用该方法，但这是一个非常昂贵的策略： 锁 – 严重限制并发，它们在现代CPU架构上非常昂贵，需要操作系统挂起线程并稍后恢复。 调用者线程正在被阻塞，所以它不能做任何其他有意义的工作。即使在桌面应用程序中，这也是不可接受的，我们希望使用户面对的部分应用程序（其UI），即使在长时间的后台作业运行时也能够响应。在后端，阻塞是完全浪费的。人们可能认为这可以通过启动新线程来补偿，但是线程也是一种昂贵的抽象。 锁定引入了新的威胁：死锁。 这些现实导致了两败俱伤的局面： 没有足够的锁，状态就会被破坏。 一个地方有许多锁定，性能受损，很容易导致死锁。 ​ 另外，锁只在本地工作良好。当涉及跨多台机器的协调时，唯一的选择是分布式锁。不幸的是，分布式锁的比本地锁效率低几个数量级，且通常会对扩展进行硬性限制。分布式锁协议需要在多台机器上通过网络进行多次往返通信，因此延迟突破天际。 ​ 在面向对象语言中，我们很少会考虑线程或线性执行路径。我们经常将系统设想为对象实例网络，对方法调用做出反应，修改其内部状态，然后通过驱动整个应用程序状态的方法调用相互通信： ​ 然而，在多线程分布式环境中，实际发生的是线程通过以下方法的调用，去“遍历”此对象实例网络。因此，线程是真正的驱动执行： 总结： 对象只能保证面对单线程访问的封装（不变量的保护），多线程执行几乎总是导致内部状态损坏。在同一个代码段中有两个竞争的线程，则无法保证数据的不变性。 虽然锁似乎是维护多线程封装的自然补救措施，但实际上它们效率低下，容易导致任何现实应用中的死锁。 锁在本地工作，分布式环境下很难拓展。 2. 共享内存在现代计算机架构上的错误认识​ 80年代至90年代的编程模型的概念中，写入变量意味着直接写入存储单元（这有点混淆了局部变量可能只存在于寄存器中）。在现代架构上 - 如果我们简化了一些事情 - CPU正在写入缓存（cache lines），而不是直接写入内存。这些高速缓存大多数是CPU核心的本地存储，也就是说，一个核心的储存写入不可见。为了使本地更改对另一个核心可见，以致对另一个线程可见，高速缓存行需要发送到另一个核心的缓存。 ​ 在JVM上，我们必须通过使用volatile标记或Atomic包装来明确地表示要跨线程共享的内存位置。否则，我们只能在锁定的部分访问它们。为什么我们不把所有变量标记为volatile？因为跨内核运输缓存是一项非常昂贵的操作！这样做会隐含地阻止所涉及的内核进行额外的工作，并导致cache coherence protocol（CPU在主内存和其他CPU传输缓存）的瓶颈。结果是运行速度大幅度降低。 ​ 即使开发人员意识到这种情况，弄清楚哪些内存位置应该被标记为volatile，还是使用哪种Atomic结构是一种黑暗的艺术。 总结： 没有真正的共享内存，CPU核心就像网络上的计算机一样，将数据块（cache lines）明确地传递给彼此。CPU间通信和网络通信有许多共同点。现在通过CPU或网络计算机传递消息是有规范的。 更加规范和有原则的方法是将状态保留在并发实体中，并通过消息明确地在并发实体之间传播数据或事件，而不是通过变量标记为共享或使用atomic数据结构来代替/隐藏消息传递。 3. 调用堆栈的错误认识​ 今天，我们经常把调用堆栈当作理所应当的。但是，它们是在并发编程并不重要的时代发明的，因为多CPU系统并不常见。调用堆栈不会跨线程，因此不要对异步调用链建模。 ​ 当线程打算将任务委派给“background”时，会出现问题。实际上，这意味着委托给另一个线程。这不能成为一个简单的方法/函数调用，因为调用是线程严格在本地执行的。通常发生的情况是，“Caller“将一个对象放入由工作线程（“Cllee”）共享的存储单元，这个存储单元在一些事件循环中被选中。这允许“Caller”线程去执行其他任务。 ​ 第一个问题是，如何通知“Caller”完成任务？但是当一个任务失败并出现异常时，会出现一个更严重的问题。异常传播到哪里？它将传播到工作线程的异常处理程序，完全忽略了实际的“Caller”是谁： ​ 这是一个严重的问题。工作线程如何处理这种情况？它可能无法解决问题，因为它通常会忽略失败的任务的目的。“Caller”线程需要以某种方式被通知，但是没有调用堆栈来解除异常。故障通知只能通过侧面通道进行，例如将错误代码放在“Caller”线程，要不就在预期结果准备好之后。如果此通知不到位，则“Caller”不会收到失败的通知，并且任务丢失！类似于网络系统如何工作，消息/请求可以丢失/失败，没有任何通知。 ​ 错误真的发生时，这种不好的情况会变得更糟，一个由线程支持的worker遇到一个错误，最终会导致一个不可恢复的情况。例如，由bug引起的内部异常会冒泡到线程的root，并使线程关闭。这就出现了一个问题，谁应该重新启动线程主持的服务的正常运行，如何恢复到已知状态？乍一看，这似乎是可以管理的，但我们突然面临着一个新的，意想不到的现象：线程当前正在工作的实际任务不在共享内存位置，而是从任务中取出（通常是一个队列）。事实上，由于异常到达顶部，丢弃所有的调用堆栈，任务状态完全丢失了！ 综上所述： 在当前系统上实现有意义的并发和性能，线程必须以有效的方式相互委派任务，而不会阻塞。使用这种风格的任务委托并发（更多的是通过网络/分布式计算），调用基于堆栈的错误处理分解，需要引入新的显式错误信号机制。 具有工作代表权的并行系统需要处理服务故障，并具有从其中恢复的原则性手段。这些服务的客户需要注意在重新启动过程中任务/消息可能会丢失。即使没有发生损失，由于先前入队的任务（长队列），垃圾收集等引起的延迟等等，响应可能会任意延迟。面对这些，并发系统应该以超时的形式处理响应超时，就像网络/分布式系统。 4.Actor模式如何满足并发、分布式系统的需求​ 如上述，常见的编程实践无法适应现代并发和分布式系统的需求。幸运的是，我们不需要废除我们所知道的一切。Actor模式以原则性的方式解决了这些缺点，从而使得系统的行为能够更好地匹配我们的心理模型。 特别的，我们想要去： 强制执行封装，而无需使用锁。 使用协作实体反应信号模型，改变状态和发送信号，推动整个应用的发展。 不要担心执行机制与我们的世界观不匹配。 以下主题描述Actor模式如何完成了这些目标。 1.使用消息的传递，避免了锁和阻塞​ 演员发送消息到彼此，而不是调用方法。发送消息不会将执行线程从发送方传送到目的地。一个Actor可以发送一个消息并继续工作，而不阻塞。因此，它可以做更多的工作，发送和接收消息。 ​ 对于对象，当一个方法返回时，它释放对其执行线程的控制。在这方面，Actor表现得很像对象，它们对消息做出反应，并在处理当前消息时返回执行。以这种方式，Actor实际上实现了我们想象的对象的执行： ​ 传递消息而不是调用方法的一个重要区别是消息没有返回值。通过发送消息，Actor将工作委托给另一个Actor。正如我们在《调用堆栈的错误认识》中看到的：如果它想要一个返回值，发送执行者将需要在同一个线程上阻止或执行其他Actor的工作。相反，接收者Actor将结果通过回复消息的方式进行传递。 ​ 我们在模型中需要的第二个关键变化是恢复封装。Actor对消息做出反应，就像对象对它们调用的方法“反应”一样。Actor独立于消息的发送者执行，并且它们一次一个地响应传入的消息；而不是多个线程“延伸”到我们的Actor中，并对内部状态和不变量造成破坏。当每个Actor按顺序处理发送给它的消息时，不同的Actor彼此并发工作，所以一个Actor系统可以同时处理多个消息，同时机器上可以使用许多处理器核心。由于每个Actor总是至多处理一个消息，所以一个Actor的变量可以保持不同步。这不会自动使用锁： 总而言之，当Actor收到消息时，会发生什么： Actor将消息添加到队列的末尾。 如果Actor没有被安排执行，它被标记为准备执行。 一个（隐藏的）调度器实体接管Actor并开始执行它。 Actor从队列的前面挑选消息。 Actor修改内部状态，向其他Actor发送消息。 Actor的执行是非计划的。 为了完成这个行为，Actor有： An Mailbox （消息的队列）。 An Behavior （Actor的状态，内部变量等）。 Messages （表示信号的数据片段，类似于方法调用及其参数）。 An Execution Environment（采取具有消息的Actor的反应和调用其消息处理代码的机制）。 An Address （稍后再说）。 ​ 消息被放入所谓的Actor邮箱中。Actor的行为描述了Actor如何响应消息（如发送更多的消息和/或改变状态）。Execution Environment编排一个线程池，完全透明地驱动所有上述操作。 这是一个非常简单的模型，它解决了之前枚举的问题： 通过将执行从信令中解耦来保留封装。 不需要锁。修改Actor的内部状态只能通过消息进行处理，一次只处理一条消息。 任何地方都没有锁，发件人没有被阻塞。数十万的Actor可以有效地安排在十几个线程上，充分发挥现代CPU的潜力。任务授权是Actor的自然操作模式。 Actor状态是本地的，不共享，变化和数据通过消息传播，映射到现代内存层次结构的实际工作原理。在许多情况下，这意味着仅在包含消息中的数据的缓存中传输，同时保持本地状态和数据缓存在原始核心。相同的模型精确地映射到远程通信，其中状态保存在机器的RAM中，并且变化/数据通过网络作为数据包传播。 2.Actor优雅地处理错误​ 由于我们不再在彼此发送消息的Actors之间存在共享的调用堆栈，所以我们需要以不同的方式处理错误情况。我们需要考虑两种错误： 第一种情况是由于任务中的错误导致目标Actor上的委派任务失败（例如一些验证问题，如不存在的用户标识）。在这种情况下，由目标Actor封装的服务是完整的，只是任务本身是错误的。服务Actor应该回复给发件人一个消息，提出错误的情况。这里没有什么特别之处，错误是域的一部分，因此是普通消息。 第二种情况是服务本身遇到内部故障时。Akka强制所有Actor被组织成一个树状的层次结构，即创建另一个Actor的Actor成为新Actor的Supervisor（父母）。这与操作系统如何将流程组合到树中非常相似。就像进程一样，当一个Actor失败时，它的父Actor被通知，它可以对失败做出反应。此外，如果父Actor停止，其所有子项也被递归停止。这项服务被称为监督，它是Akka的核心。 ​ Supervisor （父母）可以决定在某些类型的故障情况下重新启动其子Actor，或者将他们完全停止。Children永远不会静静地死亡（除了进入无限循环的例外），而是失败，Supervisor 可以对故障做出反应，或者他们（Children）被停止（在这种情况下，有兴趣的一方会自动通知）。总是有一个责任实体来管理一个Actor：它的Supervisor 。重新启动从外部不可见：协作Actor可以继续发送消息，而目标Actor重新启动。 本作品采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。]]></content>
      <categories>
        <category>Akka</category>
      </categories>
      <tags>
        <tag>Akka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Akka-Networking Cluster Usage]]></title>
    <url>%2F2017%2F06%2F12%2Fakka-networking-cluster-usage%2F</url>
    <content type="text"><![CDATA[Akka集群使用 有关Akka集群概念的介绍，请参阅集群规范。 1.为你的项目支持集群做准备 Akka集群是一个单独的jar包。 确保您的项目具有以下依赖关系： 12345&lt;dependency&gt; &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt; &lt;artifactId&gt;akka-cluster_2.11&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt;&lt;/dependency&gt; 最新的jar包版本请参考Akka官方网站。 2.一个简单的集群示例 以下配置可以启用群集扩展。 加入集群，actor订阅集群成员事件并记录它们。 application.conf配置如下所示： 123456789101112131415161718192021222324252627282930313233akka &#123; actor &#123; provider = &quot;cluster&quot; &#125; remote &#123; log-remote-lifecycle-events = off netty.tcp &#123; hostname = &quot;127.0.0.1&quot; port = 0 &#125; &#125; cluster &#123; seed-nodes = [ &quot;akka.tcp://ClusterSystem@127.0.0.1:2551&quot;, &quot;akka.tcp://ClusterSystem@127.0.0.1:2552&quot;] # 自动停机对生产环境部署是不安全的. # 您可能希望在开发过程中使用它，在文档中阅读更多信息. # # auto-down-unreachable-after = 10s &#125;&#125;# 禁用Akka集群中的legacy metrics.akka.cluster.metrics.enabled=off# 在akka-cluster-metrics中启用指标扩展(metrics extension).akka.extensions=[&quot;akka.cluster.metrics.ClusterMetricsExtension&quot;]# 测试期间提取本地Sigar native library地址.# 注意：在一个主机上运行多个jvm时，请使用per-jvm-instance文件夹.akka.cluster.metrics.native-library-extract-folder=$&#123;user.dir&#125;/target/native 要在Akka项目中启用群集功能，您至少应该添加 Remoting 设置，但是可以使用群集。通常还应将akka.cluster.seed-nodes添加到您的application.conf文件中。 注意： 如果您在Docker容器中运行Akka，或者某些其他原因的节点具有单独的内部和外部IP地址，您必须根据 Akka behind NAT or in a Docker container中配置远程处理。 种子节点被配置为最初的，自动的，集群的联结点（加入点）。 请注意，如果要在不同机器上启动节点，则需要在application.conf中指定机器的ip-addresses或host names，而不是127.0.0.1。 使用群集扩展的Actor如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package jdocs.cluster;import akka.actor.AbstractActor;import akka.cluster.Cluster;import akka.cluster.ClusterEvent;import akka.cluster.ClusterEvent.MemberEvent;import akka.cluster.ClusterEvent.MemberUp;import akka.cluster.ClusterEvent.MemberRemoved;import akka.cluster.ClusterEvent.UnreachableMember;import akka.event.Logging;import akka.event.LoggingAdapter;public class SimpleClusterListener extends AbstractActor &#123; LoggingAdapter log = Logging.getLogger(getContext().getSystem(), this); Cluster cluster = Cluster.get(getContext().getSystem()); //subscribe to cluster changes @Override public void preStart() &#123; cluster.subscribe(getSelf(), ClusterEvent.initialStateAsEvents(), MemberEvent.class, UnreachableMember.class); &#125; //re-subscribe when restart //在重启的时候会再次订阅，因此在sotp之前先取消订阅 @Override public void postStop() &#123; cluster.unsubscribe(getSelf()); &#125; @Override public Receive createReceive() &#123; return receiveBuilder() .match(MemberUp.class, mUp -&gt; &#123; log.info("Member is Up: &#123;&#125;", mUp.member()); &#125;) .match(UnreachableMember.class, mUnreachable -&gt; &#123; log.info("Member detected as unreachable: &#123;&#125;", mUnreachable.member()); &#125;) .match(MemberRemoved.class, mRemoved -&gt; &#123; log.info("Member is Removed: &#123;&#125;", mRemoved.member()); &#125;) .match(MemberEvent.class, message -&gt; &#123; // ignore &#125;) .build(); &#125;&#125; Actor将自己注册为某些集群事件的订阅者。当订阅开始时，它接收与集群的当前状态相对应的事件，然后接收到在集群中发生的更改的事件。 自己运行这个例子的最简单的方法是参照本教程下载运行Scala的Akka Cluster Sample with Scala 。它包含有关如何运行SimpleClusterApp的说明。 该示例的源代码可以在Akka Samples Repository中找到。 3.加入种子节点(Joining to Seed Nodes) 您可以决定是否手动或自动完成加入群集以配置初始联结点，即种子节点。当一个新节点启动时，它向所有种子节点发送消息，然后将join命令发送到首先应答的节点。如果没有任何一个种子节点回复（可能种子节点尚未启动），则会重试此过程，直到成功或关闭。 您可以在配置文件configuration （application.conf）中定义种子节点： 123akka.cluster.seed-nodes = [ &quot;akka.tcp://ClusterSystem@host1:2552&quot;, &quot;akka.tcp://ClusterSystem@host2:2552&quot;] 当使用以下语法启动JVM时，也可以将其定义为Java系统属性： 12-Dakka.cluster.seed-nodes.0=akka.tcp://ClusterSystem@host1:2552-Dakka.cluster.seed-nodes.1=akka.tcp://ClusterSystem@host2:2552 可以以任何顺序启动种子节点，并且不需要运行所有种子节点，但种子节点配置列表中的第一个节点必须在最初启动群集时启动，否则其他种子节点将不会被初始化，并且没有其他节点可以加入群集。原因是避免在从空集群开始时形成分离的岛屿（？？？）。同时启动所有配置的种子节点是最快的（顺序不重要），否则它会占用配置的seed-node-timeout，直到节点可以加入。 一旦启动了两个以上的种子节点，便可以关闭第一个种子节点。如果第一个种子节点重新启动，它将首先尝试加入现有群集中的其他种子节点。 如果不配置种子节点，则需要以编码方式或手动方式加入群集。 可以使用JMX或HTTP进行手动加入。 可以使用Cluster.get(system).join来以编码方式连接。在配置属性retry-unsuccessful-join-after定义的时间段后，会自动重新尝试加入节点。可以通过将属性设置为off来禁用重试。 您可以加入群集中的任何节点，它不必配置为种子节点。请注意，您只能加入已存在的集群成员，这意味着对于引导某些节点必须加入自身（？？？），随后的节点可以加入它们来组成一个集群。 您也可以使用Cluster.get(system).joinSeedNodes以编码方式加入，这在启动时通过使用某些外部工具或API动态发现其他节点时更具有优势。当使用joinSeedNodes时，您不应该包括节点本身，除了应该是第一个种子节点的节点，并且应该首先放置在joinSeedNodes参数中。 在配置属性seed-node-timeout中定义的时间段后，会自动重新尝试联系种子节点。在配置retry-unsuccessful-join-after后，会自动重试加入特定种子节点。重试意味着它尝试联系所有种子节点，然后加入首先应答的节点。如果种子节点列表中的第一个节点不能联系任何其他种子节点，在配置的seed-node-timeout后它将自己加入。 Actor系统只能加入群集一次。其他尝试将被忽略。系统成功加入集群后，必须重新启动才能加入另一个集群，或者重新加入同一个集群。重新启动后可以使用相同的主机名和端口号，当它作为群集中现有成员的新化身尝试加入时，群集中现有成员会被删除，然后才被允许加入集群。 注意： 对于集群中的所有成员，ActorSystem的名称必须相同。 该名称在启动ActorSystem时给出。 4.Dowing 当故障检测器考虑到成员无法访问时，不允许Leader履行其职责，例如将新加入成员的状态更改为“Up”。该节点必须先重新可达，否则不可达成员的状态必须更改为“Down”。将节点状态更改为“Down”可以自动或手动执行。 默认情况下，必须使用JMX或 HTTP手动完成。 它也可以使用Cluster.get(system).down(address)以编码方式执行。 Split Brain Resolver,是 Lightbend Reactive Platform的一部分，用于故障排除问题的预包装解决方案。如果您不使用RP，您应该仔细阅读Split Brain Resolver的文档documentation，并确保您使用的解决方案在此处有所描述。 自动停机 Auto-downing (DO NOT USE) 有一个自动停机功能，不应该在生产中使用。 为了测试目的，可以通过配置启用它： 1akka.cluster.auto-down-unreachable-after = 120s 这意味着在配置的不可达超时时间之后，集群Leader会将不可达到的节点状态自动更改为down。 这是从群集成员中删除不可达到的节点的天真的方法。它适用于崩溃和短暂的瞬态网络分区，但不适用于长网络分区。网络分区的两边都会看到另一边无法访问，一段时间后，它将从集群成员中删除。由于这是双方发生的，所以结果是创建了两个分离的断开的集群。这也可能是由于长时间的GC暂停或系统过载导致。 警告： 我们建议在生产中不要使用Akka Cluster的自动关闭功能。如果您使用 Cluster Singleton或Cluster Sharding，尤其是与Akka Persistence一起，这对于正确的行为至关重要。对于具有群集分片的Akka持久化，在网络分区的情况下可能导致数据损坏。 5.Leaving 从集群中删除成员有两种方法。 您可以停止Actor系统（或JVM进程）。 如上所述，在自动或手动关机后，将被检测为不可达并去除。 如果告诉集群某个节点应该离开，则可以执行更为优雅的退出。 这可以使用 JMX 或 HTTP来执行。 它也可以以编码方式执行： 12final Cluster cluster = Cluster.get(system);cluster.leave(cluster.selfAddress()); 请注意，此命令可以发布到集群中的任何成员，而不一定是要离开的成员。 当集群节点将自身视为退出时，Coordinated Shutdown 将自动运行，即从另一个节点离开将在离开节点上触发关机过程。当使用Akka群集时，会自动添加群集包括关闭Cluster Singletons和Cluster Sharding的优雅离开任务。当使用Akka Cluster时，将自动添加用于优雅的离开群集的任务，包括关闭Cluster Singletons和Cluster Sharding。即如果优雅的离开还没有在进行，运行关机过程也将触发优雅的离开。 通常这是自动处理的，但是在此过程中出现网络故障的情况下，仍可能需要将节点的状态设置为Down，以完成删除。 本作品采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。]]></content>
      <categories>
        <category>Akka</category>
      </categories>
      <tags>
        <tag>Akka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Akka-Networking Cluster Specification]]></title>
    <url>%2F2017%2F06%2F11%2Fakka-networking-cluster-specification%2F</url>
    <content type="text"><![CDATA[Akka：集群规范Akka集群提供容错的(fault-tolerant)分散式(decentralized)基于点对点的(peer-to-peer based)集群成员服务，没有单点故障或单点瓶颈。Akka集群使用Gossip协议和自动故障检测器(automatic failure detector)。 1. 术语1. 节点(node) 集群的逻辑成员。一台物理机上可能有多个节点。一个节点由节点标识符：[ hostname : port : uid ]定义。 2. 集群(cluster) 通过成员服务(membership service)连接在一起的一组节点。 3. 领导(Leader) 集群中的单个节点充当领导者。管理集群收敛和成员状态转换。 2. 成员(Membership) 集群由一组成员节点组成。每个节点的标识符是一个[ hostname : port : uid ]元组。一个Akka应用程序可以分布在一个集群上，每个节点都承载了应用程序的某些部分。集群成员和运行在该应用程序节点上的Actor是不挂钩的(decoupled)。一个不托管任何Actor节点也可以是集群的成员。可以通过向集群中的一个节点发出JOIN命令来加入集群。 节点标识符内部还包含唯一标识该Actor系统实例的UID [ hostname : port ]。Akka使用UID能够可靠的触发远程死亡监视(remote death watch)。这意味着相同的Actor系统一旦从集群中删除，就不能再次加入集群。要将一个具有相同[ hostname : port ]的Actor系统重新加入到集群中，必须先停止Actor系统并启动一个新的具有相同 [ hostname : port ] 的Actor系统，然后它接收一个不同的UID。 集群成员状态是专门的CRDT，这意味着它具有单独合并功能。当不同节点发生并发更改时，更新可以始终被合并并收敛到相同的最终结果。 3. Gossip Akka的集群基于Amazon的Dynamo系统，特别是Basho的Riak分布式数据库中采用的方法。集群成员使用Gossip协议进行沟通交流，其中集群的当前状态通过流言(gossiped)随机的在集群中散布，优先散布到没有接收到集群最新版本的成员。 1.向量时钟(Vector Clocks) 向量时钟是一种用于在分布式系统中生成事件的部分排序并检测因果关系违规的数据结构和算法。 我们使用向量时钟来协调和合并在Gossip期间的集群状态差异。向量时钟是一组(node, counter)。对集群状态的每次更新都会伴随向量时钟的更新。 2.Gossip 收敛(Gossip Convergence) 有关集群的信息在某个时间点在本地节点收敛。这是当一个节点可以证明他正在观察的集群状态已经被集群中的所有其他节点观察到。通过传递在Gossip期间看到当前状态版本的一组节点来实现收敛，这个信息被称为在Gossip概述中看到的集合。当所有节点都包含在所看到的集合中，则会收敛。 当有任何节点变为不可达状态时(unreachable)，不能发送收敛。节点需要重新变为可达状态(reachable)，或移动到down和remove状态（参见下面的Membership Lifecycle部分）。这只会组织Leader执行其集群成员管理，并不会影响在集群上运行的应用程序。例如，这意味着在网络分区期间，无法向集群添加更多节点。节点可以加入(join)，但是在分区已经愈合或者不可达接待你已被关闭之前，新加入的节点不会被移动为up状态。 3.故障检测器(Failure Detector) 故障检测器负责检测节点是否与集群其余部分不可达(unreachable)。为此，我们正在使用Hayashibara等人的“Phi应计失效检测器”The Phi Accrual Failure Detector 的实现。 应计失效检测器解耦监测和解释。这使得它们适用于更广泛的场景，并且更适合构建通用故障检测服务。这个想法是保持故障统计历史，从其他节点收到的心跳计算出来，并尝试通过考虑多个因素进行有针对性的猜测，以及如何随着时间的推移积累，以便提出更好的猜测一个特定的节点的状态是up还是down。 通过询问节点是否关闭(is the node down?)，而不仅是回答“是”或“否”。它返回一个表示节点关闭的可能性的phi值。 作为计算基础的阈(yù)值(threshold )可由用户配置。低阈值容易产生许多错误的怀疑，但确保在发生真实崩溃的情况下进行快速检测。相反，高阈值会产生较少的错误，但需要更多时间来检测实际的崩溃。 默认阈值为8，适用于大多数情况。然而，在云环境（如Amazon EC2）中，该值可以增加到12，以便解决有时在这些平台上发生的网络问题。 在一个群集中，每个节点由几个其他节点进行监视（默认最大5个），当任何一个节点检测到节点不可达时，信息将通过Gossip扩展到群集的其余部分。换句话说，只要有一个节点标记一个节点不可达，其余的集群便会标记该节点不可达。 要监视的节点从散列有序节点环中的邻居中选出。 这是为了增加对框架(racks)和数据中心进行监控的可能性，但所有节点上的顺序是相同的，这确保了全面的覆盖。 心跳每隔一秒发出一次，每次心跳都会在用作故障检测器的输入的回复请求/回复握手中执行。 故障检测器还将检测节点是否再次可达。 当监听不可达节点的所有节点将其再次检测到可以再次到达时，在Gossip传播后，集群将认为它是可达到的。 如果无法将系统消息传递到节点，则会将其隔离，并无法从不可访问的状态恢复。 如果存在太多未确认的系统消息（例如监视，终止，远程Actor部署，由远程父节点监督的Actor的失败），则可能发生这种情况。 然后，节点需要移动到down或remove状态（参见下面的Membership Lifecycle部分），并且必须重新启动 Actor系统才能再次加入群集。 4.Leader 在Gossip收敛后，可以确定集群的领导者。没有领导者的选举过程，无论何时有Gossip收敛，任何一个节点都可以确定地认出领导者。领导者只是一个角色，任何一个节点都可以成为领导者，它可以在收敛轮次之间改变。领导者只是排序顺序的第一个能够发挥领导作用的节点，领导者的首选成员状态为up和leaving（有关成员状态的更多信息，请参阅下面的Membership Lifecycle部分）。 领导者的作用是管理成员加入或退出集群，将加入(joining)的成员转变为up状态或将推出(exiting)的成员转变为removed状态。目前领导者的行为只能通过接收具有Gossip收敛的新的群集状态来触发。 如果配置好，领导者也有权力将“根据故障检测器被认为是不可达”的节点“自动关闭”。 5.种子节点(Seed Nodes) 种子节点被配置为加入群集的新节点的接触点。当新节点启动时，它会向所有种子节点发送一条消息，然后发送一个join命令到首先应答的种子节点。 种子节点配置值对运行的集群本身没有任何影响，它只与加入集群的新节点有关，因为它可以帮助他们找到联系点来发送join命令；新成员可以将此命令发送到集群中的任何当前成员，而不仅仅是到种子节点。 6.Gossip 协议(Gossip Protocol) 推挽(push-pull)Gossip的变化是用来减少围绕群集发送的Gossip信息的数量。在推挽Gossip中，发送摘要代表当前版本，但不是实际值; Gossip的收件人可以发回任何具有较新版本的值，并且还请求具有过时版本的值。Akka使用单个共享状态与向量时钟进行版本控制，因此在Akka中使用的推挽Gossip变体使用此版本：只需按需要推送实际状态。 定期地，默认值是每1秒一次，每个节点选择另一个随机节点来发起一轮Gossip。如果不到一半的节点驻留在所看到的集合中（已经看到新的状态），那么该集群会闲话3次而不是每秒一次。这种调整后的Gossip间隔是在状态改变之后的早期传播阶段加快收敛过程的一种方式。 对要Gossip的节点的选择是随机的，但它偏向于可能没有看到当前状态版本的节点。在没有收敛的每轮Gossip交换中，它使用0.8（可配置）的概率来传播到不是所看到的集合的一部分的节点，即可能具有较旧版本的状态的节点。否则Gossip到任何随机的live节点。 这种有偏心的选择是在状态改变后的后期传播阶段，加快收敛过程的一种方式。 对于大于400个节点（可配置，并通过经验证据表明）的集群，0.8概率逐渐减小，以避免具有太多并发Gossip请求的压倒单个信息落后的节点。Gossip接收器还有一种机制，通过删除已经在邮箱中排队太长时间的消息来保护自己免受太多并发的Gossip消息。 当集群处于收敛状态时，gossiper只发送一个包含Gossip版本的Gossip状态消息到选定的节点。一旦集群发生变化（意味着非收敛），那么它再次回到偏心的Gossip。 Gossip状态或Gossip状态的接收者可以使用Gossip版本（向量时钟）(gossip version (vector clock) )来确定： 1231. 它有一个较新版本的Gossip状态，在这种情况下，它将较新版本的Gossip状态发送回到gossiper。2. 它有一个过时的状态版本，在这种情况下，收件人通过发回其Gossip状态的版本来请求来自gossiper的当前状态。3. 它具有冲突的Gossip版本，在这种情况下，不同的版本被合并并发回。 如果收件人和Gossiper具有相同的版本，则不会发送或请求Gossip状态。 Gossip的周期性有一个很好的状态变化的批处理。例如，将多个节点快速连接到一个节点将导致只有一个状态改变被传播到集群中的其他成员。 Gossip消息通过protobuf进行序列化，并且gzip压缩以减少有效负载大小。 4.成员生命周期(Membership Lifecycle) 节点从joining状态开始。 一旦所有节点都看到新节点正在加入（通过Gossip收敛），Leader将会将成员状态设置为up。 如果节点以安全，预期的方式离开集群，则它切换到leaving状态。一旦Leader看leaving状态的节点上的收敛，Leader将会将其移动到exiting状态。 一旦所有节点都看到了exiting状态（收敛），则Leader将从集群中删除节点，将其标记为removed。 如果节点不可达(unreachable )，则Gossip是不可能收敛的，因此任何Leader的行为(actions)也是不可能的（例如，允许节点成为集群的一部分）。为了能够前进发展，必须改变不可达节点的状态。不可达的节点必须再次可达(reachable )或标记为down。如果该节点要再次加入群集，则必须重新启动该actor系统并再次通过加入进程(joining process)。集群可以通过Leader在配置的不可达性时间超时后自动关闭节点。如果不可达节点的新化身试图重新加入集群，在集群中的旧的化身将被标记为关闭，新的化身可以重新加入集群而无需手动干预。 注意： ​ 如果启用了自动关闭功能、触发了故障检测器，并且您没有采取措施关闭已经无法访问的节点，则最终会导致出现许多单个节点的群集。 这是因为无法访问的节点可能会看到其余的集群无法访问，则成为自己的Leader并形成自己的集群。 如前所述，如果节点不可达，则Gossip是不可能收敛的，因此任何Leader的行为也是不可能的。通过启用akka.cluster.allow-weakly-up-member（默认启用），可以在尚未达到收敛的同时促进新节点的加入。这些新连接的节点将被提升为WeaklyUp状态。 一旦达到Gossip收敛Leader将WeaklyUp状态的成员移至Up。 请注意，网络分区另一侧的成员对新成员是否存在并不了解。 例如，您不应该在做群体决策的时候统计WeaklyUp状态的成员数量。 1.成员状态(Member States) joining - 加入群集时的瞬时状态 weakly up - 网络拆分(network split)时的瞬时状态（只有当`akka.cluster.allow-weakly-up-members=on） up - 正常运行状态 leaving / exiting - 优雅的删除过程中的状态 down - 标记为 down (不再是集群决策的一部分) removed - 墓碑状态（不再是集群成员） 2.用户行为(User Actions) join - 将单个节点连接到集群 - 如果在配置中指定了要加入的节点，则可以显式或自动启动 leave - 告诉节点优雅的离开集群 down - 标识一个节点为down 3.领导者行为(Leader Actions) ​ 集群Leader有以下职责： 将成员加入和移出群集 joining –&gt; up exiting –&gt; removed 4.故障检测和不可达性(Failure Detection and Unreachability) fd * - 其中一个监控节点的故障检测器已经触发，导致被监视节点被标记为不 5.成员状态图（akka.cluster.allow-weakly-up-members = off） 6.成员状态图 (akka.cluster.allow-weakly-up-members=on) 本作品采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。]]></content>
      <categories>
        <category>Akka</category>
      </categories>
      <tags>
        <tag>Akka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Case Perfect Number]]></title>
    <url>%2F2017%2F06%2F04%2Fcase-perfect-number%2F</url>
    <content type="text"><![CDATA[案例分析：完美数的分类 区分自然数：完美数、过剩数和不足数。 完美数（Perfect number），又称完美数或完备数，是一些特殊的自然数。它所有的真约数（即除了自身以外的约数）的和（即因子函数），恰好等于它本身。如果一个数恰好等于它的因子之和，则称该数为“完全数”。 过剩数（盈数）：对于“12”这个数，它的真约数有1、2、3、4、6，其和是16，比12本身大，像这样的自然数叫做盈数。 不足数（亏数）：对于“4”这个数，它的真约数有1、2，其和是3，比4本身小，像这样的自然数叫做亏数。所以，完全数就是既不盈余，也不亏欠的自然数。 自然数分类规则 完美数 真约数之和 = 数本身 过剩数 真约数之和 &gt; 数本身 不足数 真约数之和 &lt; 数本身 1. 命令式解法 Java语言传统的命令式解法 123456789101112131415161718192021222324252627282930313233343536373839public class NumberClassifier &#123; public static boolean isFactor(final int number, final int potential)&#123; return number % potential == 0; &#125; public static Set&lt;Integer&gt; getFactors(final int number) &#123; Set&lt;Integer&gt; factors = new HashSet&lt;&gt;(); factors.add(1); factors.add(number); for (int i = 2; i &lt; number; i++) &#123; if (isFactor(number, i)) &#123; factors.add(i); &#125; &#125; return factors; &#125; public static int aliquoSum(final Collection&lt;Integer&gt; factors) &#123; int sum = 0; int targetNumber = Collections.max(factors); for (Integer i : factors) &#123; sum += i; &#125; return sum - targetNumber; &#125; public static boolean isPerfect(final int number) &#123; return aliquoSum(getFactors(number)) == number; &#125; public static boolean isAbundant(final int number) &#123; return aliquoSum(getFactors(number)) &gt; number; &#125; public static boolean isDeficient(final int number)&#123; return aliquoSum(getFactors(number)) &lt; number; &#125;&#125; 2. 函数式实现（Java8） 采用Java8中的StreamAPI实现 1234567891011121314151617181920212223public class NumberClassifier &#123; public static IntStream factorsOf(int number) &#123; return IntStream.range(1, number + 1) .filter(potential -&gt; number % potential == 0); &#125; public static int aliquotSum(int number) &#123; return factorsOf(number).sum() - number; &#125; public static boolean isPerfect(int number) &#123; return aliquotSum(number) == number; &#125; public static boolean isAbundant(int number)&#123; return aliquotSum(number) &gt; number; &#125; public static boolean isDeficient(int number) &#123; return aliquotSum(number) &lt; number; &#125;&#125; 本作品采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。]]></content>
      <categories>
        <category>Case_Analysis</category>
      </categories>
      <tags>
        <tag>Case_Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How To Solve]]></title>
    <url>%2F2017%2F06%2F01%2Fhow-to-solve-it%2F</url>
    <content type="text"><![CDATA[如何求解 引用一段秦小波对《深入理解Java虚拟机》书评中的一段： 在武侠的世界里，无论是至刚至强的《易筋经》，还是阴柔无比的《葵花宝典》，都离不开内功修炼。没有内功心法，这些武术都只是花拳绣腿的拙劣表演而已。软件业是武林的一个翻版，也有大量的模式、套路、规范等外功，但“外功修行，内功修神”。。。 这篇文章就是我工作和生活遵从的内功心法。 不论是我们在生活中遇到了困难，还是在工作上遇到了新的问题，我们都要去找到解决困难、问题最好的办法，找到一个最优解。在求解时，清晰地求解过程至关重要。 1. 必须理解问题 未知量是什么？已知数据是什么？条件是什么？条件有可能满足吗？条件是否足以确定未知量？条件是否充分？是否多余？是否矛盾？ 画一张图，列出已知的条件与待解决的问题。 2. 找出已知与未知的联系 能够重新重新叙述这个问题吗？还能以不同的方式叙述他吗？ 回到定义上去。 如果你不能理解整个问题，先尝试去理解某些相关的问题。能否想到一些更普遍化的问题，一个类似的问题？能解决这个问题的一部分吗？能从已知条件中得到一些有用的东西吗？能想到适合的条件来确定未知量吗？你能改变未知量或已知条件，从而使新的未知量和新的已知数据彼此更接近吗？你用到所有的已知数据吗？你用到全部的条件了吗？你把问题中的所有关键概念都考虑到了吗？ 如果找不到直接的联系，也许不得不考虑辅助条件。 最终你应该得到一个解决方案。 3. 执行你的方案 执行你的解决方案，检查每一个步骤。 你能清楚地看出这个步骤是正确的吗？ 你能否证明它是正确的？ 4. 检查以及得到的答案 你能检验这个结果吗？ 你能检验这个论证吗？ 你能在不同的问题上利用这个结果或者方法吗？ 本作品采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。]]></content>
      <categories>
        <category>Thought</category>
      </categories>
      <tags>
        <tag>Thought</tag>
      </tags>
  </entry>
</search>
